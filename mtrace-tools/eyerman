#!/usr/bin/python

import os
import sys
import json
import math

if len(sys.argv) != 3:
    print >> sys.stderr, 'usage: %s number-of-cores mscan-json' % \
        os.path.basename(sys.argv[0])
    exit(2)

N_cores = int(sys.argv[1])
jsonDict = json.loads(open(sys.argv[2]).read())
raw = jsonDict['eyerman']
serials =jsonDict['serial-sections']

realSerials = []
sumSerials = 0.0
serialCycles = 0.0
for s in serials:
    n = 0
    for p in s['per-cpu-percent']:
        if p > 0.0:
            n += 1
    if n >= 2:
        realSerials.append(float(n))
        sumSerials += float(n)
        serialCycles += s['total-cycles']
print 'sumSerials %.2f' % sumSerials
print 'serialCycles %.2f' % serialCycles

# Fraction of sequential code
F_seq = 0.0
print 'F_seq %.2f' % F_seq
# Fraction of parallel code, broken down into two terms:
#  - Indefinitely parallelizable (No Critial Sections)
F_par_ncs = (float(raw['total']) - serialCycles) / float(raw['total'])
print 'F_par_ncs %.2f' % F_par_ncs
#  - Parallelizable but requires synchronization (Critical Sections)
F_par_cs = 1 - F_par_ncs
print 'F_par_cs %.2f' % F_par_cs

# Probability of executing a critical section given a core is executing in
# a parallel section (since F_seq == 0, equal to P_cs)
P_cs = (F_par_cs) / (F_par_cs + F_par_ncs)
print 'P_cs %.2f' % P_cs

# The probability that two randomly choosen critical sections contend
P_ctn = 0.0
for s in realSerials:
    P_ctn += (s / sumSerials) * ((s - 1.0) / (sumSerials - 1.0))

print 'P_ctn %.2f' % P_ctn

T_seq = F_seq
print 'T_seq %.2f' % T_seq

T_par_ncs = F_par_ncs / N_cores
print 'T_par_ncs %.2f' % T_par_ncs

T_par_cs = F_par_cs * ((P_cs * P_ctn) + (1 - (P_cs * P_ctn)) * (1.0 / float(N_cores)))
print 'T_par_cs %.2f' % T_par_cs

T = T_seq + T_par_ncs + T_par_cs
print 'T %.2f' % T

print 'S %.2f' % (1 / T)
